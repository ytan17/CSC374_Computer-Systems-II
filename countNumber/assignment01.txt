CSC 374: Computer Systems II: 2017 Winter
Assignment #1

Last Modified 2017 January 17

Purpose:

To go over:
Compiler optimizations
Program profiling (timing)
Header files
Linking and object file layout
Computing

Please ssh into one of the following:

140.192.36.184
140.192.36.185
140.192.36.186
140.192.36.187
or use your own Linux machine.
Please submit a .zip file (not .7z or any other non-standard compression!) file of your header file and a .txt/.pdf/.doc/.odt file containing your answer to the questions.

Please copy-and-paste the following files (0 Points):

list.c

/*-------------------------------------------------------------------------*
 *---									---*
 *---		list.c							---*
 *---									---*
 *---	    This file defines struct(s) and functions for counting	---*
 *---	randomly-generated integers in a linked list.			---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a		2017 January 2		Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

#include	"header.h"

//  PURPOSE:  To hold elements of a linked list that holds counts of integers.
struct		ListElement
{
  int			item_;
  int			count_;
  struct ListElement*	nextPtr_;
};


//  PURPOSE:  To count the occurrence of 'numNums' numbers generated by
//	'getNextNumber()'.  Returns linked list with counts.
struct ListElement*
		generateList	(int	numNums
				)
{
  struct ListElement*	toReturn	= NULL;
  struct ListElement*	prev;
  struct ListElement*	run;
  int	 		i;

  for  (i = 0;  i < numNums;  i++)
  {
    int	nextNum	= getNextNumber();

    for  (prev=NULL, run=toReturn;  run!=NULL;  prev=run, run=run->nextPtr_)
      if  (run->item_ == nextNum)
      {
	run->count_++;
        break;
      }

    if  (run == NULL)
    {
      struct ListElement* newItemPtr = (struct ListElement*)
      	     		  	       malloc(sizeof(struct ListElement));

      newItemPtr->item_		= nextNum;
      newItemPtr->count_	= 1;
      newItemPtr->nextPtr_	= NULL;

      if  (prev == NULL)
        toReturn	= newItemPtr;
      else
	prev->nextPtr_	= newItemPtr;
    }

  }

  return(toReturn);
}


//  PURPOSE:  To print the list of counts pointed to by 'listPtr'.  No return
//	value.
void		printList	(struct ListElement*	listPtr
				)
{
  while  (listPtr != NULL)
  {
    printf("%d: %d time(s)\n",listPtr->item_,listPtr->count_);
    listPtr = listPtr->nextPtr_;
  }
}


//  PURPOSE:  To free the list pointed to by 'listPtr'.  No return value.
void		freeList	(struct ListElement*	listPtr
				)
{
  struct ListElement*	next;

  while  (listPtr != NULL)
  {
    next	= listPtr->nextPtr_;
    free(listPtr);
    listPtr	= next;
  }

}


//  PURPOSE:  To count the occurrence of 'numNums' numbers generated by
//	'getNextNumber()' and put the counts in a linked-list.  Prints this
//	list, and then free()s it.  No return value.
void		countWithList	(int	numNums
				)
{
  struct ListElement*	listPtr	= generateList(numNums);

  printList(listPtr);
  freeList (listPtr);
}	  
tree.c

/*-------------------------------------------------------------------------*
 *---									---*
 *---		tree.c							---*
 *---									---*
 *---	    This file defines struct(s) and functions for counting	---*
 *---	randomly-generated integers in an unbalanced binary tree.	---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a		2017 January 2		Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

#include	"header.h"

//  PURPOSE:  To hold elements of a tree that holds counts of integers.
struct		TreeElement
{
  int			item_;
  int			count_;
  struct TreeElement*	leftPtr_;
  struct TreeElement*	rightPtr_;
};


//  PURPOSE:  To count the occurrence of 'numNums' numbers generated by
//	'getNextNumber()'.  Returns binary tree with counts.
struct TreeElement*
		generateTree	(int	numNums
				)
{
  struct TreeElement*	toReturn	= NULL;
  struct TreeElement*	prev;
  struct TreeElement*	run;
  int	 		i;

  for  (i = 0;  i < numNums;  i++)
  {
    int	nextNum	= getNextNumber();

    for  (prev=NULL, run=toReturn;  run!=NULL; )
    {
      if  (run->item_ == nextNum)
      {
	run->count_++;
        break;
      }

      prev	= run;

      if  (run->item_ > nextNum)
        run = run->leftPtr_;
      else
        run = run->rightPtr_;

    }

    if  (run == NULL)
    {
      struct TreeElement* newItemPtr = (struct TreeElement*)
      	     		  	       malloc(sizeof(struct TreeElement));

      newItemPtr->item_		= nextNum;
      newItemPtr->count_	= 1;
      newItemPtr->leftPtr_	= NULL;
      newItemPtr->rightPtr_	= NULL;

      if  (prev == NULL)
        toReturn	= newItemPtr;
      else
      if  (prev->item_ > nextNum)
	prev->leftPtr_	= newItemPtr;
      else
	prev->rightPtr_	= newItemPtr;
    }

  }

  return(toReturn);
}


//  PURPOSE:  To print the subtree of counts pointed to by 'treePtr'.  No
//	return value.
void		printTree	(struct TreeElement*	treePtr
				)
{
  if  (treePtr != NULL)
  {
    printTree(treePtr->leftPtr_);
    printf("%d: %d time(s)\n",treePtr->item_,treePtr->count_);
    printTree(treePtr->rightPtr_);
  }
}


//  PURPOSE:  To free the subtree pointed to by 'treePtr'.  No return value.
void		freeTree	(struct TreeElement*	treePtr
				)
{
  if  (treePtr != NULL)
  {
    freeTree(treePtr->leftPtr_);
    freeTree(treePtr->rightPtr_);
    free(treePtr);
  }
}


//  PURPOSE:  To count the occurrence of 'numNums' numbers generated by
//	'getNextNumber()' and put the counts in an unbalanced binary tree.
//	Prints this tree, and then free()s it.  No return value.
void		countWithTree	(int	numNums
				)
{
  struct TreeElement*	treePtr	= generateTree(numNums);

  printTree(treePtr);
  freeTree (treePtr);
}	  
C programming (20 Points):

These two files need a main() to run their functions countWithList() and countWithTree(). Then all three C files need a header file to inform them of what the others have that they need. Please finish both the main() and header.h.

Please note! Not everything needs to be shared.

main() needs countWithList() and countWithTree()
Both countWithList() and countWithTree() need getNextNumber().
Otherwise, it is best not to share too much, kind of like keeping methods and members private in C++ and Java.
header.h

/*-------------------------------------------------------------------------*
 *---									---*
 *---		header.h						---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a		2017 January 2		Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

#include	<stdlib.h>
#include	<stdio.h>
#include	<string.h>

#define		MAX_LINE	256

#define		RANGE_LOWEST	0

#define		RANGE_HIGHEST	32767

#define		MIN_NUM_NUMBERS	0

#define		MAX_NUM_NUMBERS	0x40000000
	  
main.c

/*-------------------------------------------------------------------------*
 *---									---*
 *---		main.c							---*
 *---									---*
 *---	    This file defines the functions getNextNumber(),		---*
 *---	obtainNumberBetween() and main() needed for the program of	---*
 *---	assignment 1.							---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a		2017 January 2		Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

#include	"header.h"


//  PURPOSE:  To hold the lowest allowed random number. 
int		low;


//  PURPOSE:  To hold the highest allowed random number. 
int		high;


//  PURPOSE:  To return another randomly-generated number.
int		getNextNumber	()
{
  return( (rand() % (high - low + 1)) + low );
}


//  PURPOSE:  To repeatedly ask the user the text "Please enter ", followed
//	by the text in 'descriptionCPtr', followed by the numbers 'low' and
//	'high', and to get an entered integer from the user.  If this entered
//	integer is either less than 'low', or is greater than 'high', then
//	the user is asked for another number.  After the user finally enters
//	a legal number, this function returns that number.
int		obtainNumberBetween
				(const char*	descriptionCPtr,
				 int   		low,
				 int		high
				)
{
  char	line[MAX_LINE];
  int	entry;

  // YOUR CODE HERE
}


//  PURPOSE:  To use the function obtainNumberBetween() to obtain the values
//  	for global variable 'low' (which must be between RANGE_LOWEST and
//  	 RANGE_HIGHEST), global variable 'high' (which must be between 'low'
//  	 and RANGE_HIGHEST), and local variable 'numNum' (which must be between
//  	 MIN_NUM_NUMBERS and MAX_NUM_NUMBERS).
//  	 Then it enters a loop asking the user what they want to do.  If the
//  	 user chooses integer 1 then the program runs countWithList(numNums).
//  	 If the user chooses integer 2 then the program runs
//  	 countWithTree(numNums).  If the user chooses 0 then the program quits.
//  	 Returns 'EXIT_SUCCESS' to OS.
int		main		()
{
  int	numNums;
  int	choice;
  const char*	msgCPtr	= "What would you like to do?\n"
			  "(1) Count with a list\n"
			  "(2) Count with a tree\n"
			  "(0) Quit\n"
			  "Your choice ";

  // YOUR CODE HERE

  return(EXIT_SUCCESS);
}
	  
Sample Initial Output:

$ ./assign1-0 
Please enter the lowest number in the range (0-32767): -6
Please enter the lowest number in the range (0-32767): 65536
Please enter the lowest number in the range (0-32767): 1
Please enter the highest number in the range (1-32767): 0
Please enter the highest number in the range (1-32767): 32768
Please enter the highest number in the range (1-32767): 512
Please enter the number of numbers to consider (0-1073741824): 10000000
Please enter What would you like to do?
(1) Count with a list
(2) Count with a tree
(0) Quit
Your choice  (0-2): 
	  
